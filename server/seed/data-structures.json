[
  {
    "slug": "array",
    "name": "Array",
    "description": "Static array operations in C",
    "order": 1,
    "tags": ["linear", "fundamental"],
    "related": ["linked-list", "stack"],
    "codeSnippets": [
      {
        "id": "array-c-basic",
        "language": "c",
        "title": "Array: insert, delete, traverse (C)",
        "complexity": { "time": "O(n)", "space": "O(1)" },
        "code": "#include <stdio.h>\n\nvoid traverse(int a[], int n){ for(int i=0;i<n;i++) printf(\"%d \", a[i]); printf(\"\\n\"); }\n\nint insertAt(int a[], int *n, int cap, int idx, int val){ if(*n>=cap||idx<0||idx>*n) return 0; for(int i=*n;i>idx;i--) a[i]=a[i-1]; a[idx]=val; (*n)++; return 1; }\n\nint deleteAt(int a[], int *n, int idx){ if(idx<0||idx>=*n) return 0; for(int i=idx;i<*n-1;i++) a[i]=a[i+1]; (*n)--; return 1; }\n\nint main(){ int a[100]={1,3,5,7,9}; int n=5; traverse(a,n); insertAt(a,&n,100,2,42); traverse(a,n); deleteAt(a,&n,4); traverse(a,n); return 0; }"
      }
    ]
  },
  {
    "slug": "linked-list",
    "name": "Linked List",
    "description": "Singly linked list in C",
    "order": 2,
    "tags": ["linear"],
    "related": ["queue", "stack"],
    "codeSnippets": [
      {
        "id": "ll-c-basic",
        "language": "c",
        "title": "Singly Linked List (C)",
        "complexity": { "time": "O(n)", "space": "O(1)" },
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node{ int data; struct Node* next; } Node;\n\nNode* push_back(Node* head, int val){ Node* n=(Node*)malloc(sizeof(Node)); n->data=val; n->next=NULL; if(!head) return n; Node* cur=head; while(cur->next) cur=cur->next; cur->next=n; return head; }\n\nNode* delete_at(Node* head, int idx){ if(!head||idx<0) return head; if(idx==0){ Node* t=head->next; free(head); return t; } Node* cur=head; for(int i=0;i<idx-1 && cur->next;i++) cur=cur->next; if(cur->next){ Node* t=cur->next; cur->next=t->next; free(t);} return head; }\n\nvoid print(Node* head){ for(Node* p=head;p;p=p->next) printf(\"%d \", p->data); printf(\"\\n\"); }\n\nint main(){ Node* head=NULL; head=push_back(head,10); head=push_back(head,20); head=push_back(head,30); print(head); head=delete_at(head,1); print(head); return 0; }"
      }
    ]
  },
  {
    "slug": "queue",
    "name": "Queue",
    "description": "Queue using circular array in C",
    "order": 3,
    "tags": ["linear"],
    "related": ["linked-list"],
    "codeSnippets": [
      {
        "id": "queue-c-array",
        "language": "c",
        "title": "Queue (circular array)",
        "complexity": { "time": "O(1)", "space": "O(n)" },
        "code": "#include <stdio.h>\n#define CAP 8\n\ntypedef struct { int a[CAP]; int front; int rear; int size; } Queue;\n\nvoid init(Queue* q){ q->front=0; q->rear=-1; q->size=0; }\nint empty(Queue* q){ return q->size==0; }\nint full(Queue* q){ return q->size==CAP; }\nint enqueue(Queue* q,int x){ if(full(q)) return 0; q->rear=(q->rear+1)%CAP; q->a[q->rear]=x; q->size++; return 1; }\nint dequeue(Queue* q,int* out){ if(empty(q)) return 0; *out=q->a[q->front]; q->front=(q->front+1)%CAP; q->size--; return 1; }\nint main(){ Queue q; init(&q); enqueue(&q,1); enqueue(&q,2); int v; dequeue(&q,&v); printf(\"%d\\n\", v); return 0; }"
      }
    ]
  },
  {
    "slug": "stack",
    "name": "Stack",
    "description": "Stack using array in C",
    "order": 4,
    "tags": ["linear"],
    "related": ["queue"],
    "codeSnippets": [
      {
        "id": "stack-c-array",
        "language": "c",
        "title": "Stack (array)",
        "complexity": { "time": "O(1)", "space": "O(n)" },
        "code": "#include <stdio.h>\n#define CAP 16\n\ntypedef struct { int a[CAP]; int top; } Stack;\n\nvoid init(Stack* s){ s->top=-1; }\nint empty(Stack* s){ return s->top==-1; }\nint full(Stack* s){ return s->top==CAP-1; }\nint push(Stack* s,int x){ if(full(s)) return 0; s->a[++s->top]=x; return 1; }\nint pop(Stack* s,int* out){ if(empty(s)) return 0; *out=s->a[s->top--]; return 1; }\nint main(){ Stack s; init(&s); push(&s,5); push(&s,7); int v; pop(&s,&v); printf(\"%d\\n\", v); return 0; }"
      }
    ]
  },
  {
    "slug": "binary-tree",
    "name": "Binary Tree",
    "description": "Binary tree insert (simple) and traversals in C",
    "order": 5,
    "tags": ["non-linear"],
    "related": ["bst"],
    "codeSnippets": [
      {
        "id": "bt-c-basic",
        "language": "c",
        "title": "Binary Tree: insert left/right, traversals",
        "complexity": { "time": "O(n)", "space": "O(n)" },
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node{ int val; struct Node* left; struct Node* right; } Node;\nNode* node(int v){ Node* n=(Node*)malloc(sizeof(Node)); n->val=v; n->left=n->right=NULL; return n; }\nvoid inorder(Node* r){ if(!r) return; inorder(r->left); printf(\"%d \", r->val); inorder(r->right);}\nvoid preorder(Node* r){ if(!r) return; printf(\"%d \", r->val); preorder(r->left); preorder(r->right);}\nvoid postorder(Node* r){ if(!r) return; postorder(r->left); postorder(r->right); printf(\"%d \", r->val);}\nint main(){ Node* r=node(10); r->left=node(5); r->right=node(15); r->left->right=node(7); inorder(r); printf(\"\\n\"); preorder(r); printf(\"\\n\"); postorder(r); return 0; }"
      }
    ]
  },
  {
    "slug": "bst",
    "name": "Binary Search Tree",
    "description": "BST insert/delete and inorder in C",
    "order": 6,
    "tags": ["non-linear"],
    "related": ["binary-tree"],
    "codeSnippets": [
      {
        "id": "bst-c-basic",
        "language": "c",
        "title": "BST: insert, delete, inorder",
        "complexity": { "time": "O(h)", "space": "O(h)" },
        "code": "#include <stdio.h>\n#include<stdlib.h>\n\ntypedef struct Node{ int val; struct Node* left; struct Node* right; } Node;\nNode* node(int v){ Node* n=(Node*)malloc(sizeof(Node)); n->val=v; n->left=n->right=NULL; return n; }\nNode* insert(Node* r,int v){ if(!r) return node(v); if(v<r->val) r->left=insert(r->left,v); else r->right=insert(r->right,v); return r; }\nNode* minNode(Node* r){ while(r->left) r=r->left; return r; }\nNode* delete(Node* r,int v){ if(!r) return NULL; if(v<r->val) r->left=delete(r->left,v); else if(v>r->val) r->right=delete(r->right,v); else { if(!r->left) { Node* t=r->right; free(r); return t; } else if(!r->right){ Node* t=r->left; free(r); return t; } else { Node* t=minNode(r->right); r->val=t->val; r->right=delete(r->right,t->val); } } return r; }\nvoid inorder(Node* r){ if(!r) return; inorder(r->left); printf(\"%d \", r->val); inorder(r->right);}\nint main(){ Node* r=NULL; int a[]={5,2,7,1,3,6,8}; for(int i=0;i<7;i++) r=insert(r,a[i]); inorder(r); printf(\"\\n\"); r=delete(r,7); inorder(r); return 0; }"
      }
    ]
  }
]
